<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1466651583694">{:repl-history {:ide [], :local [&quot;(rest [1 2 3])&quot; &quot;[1 2 3]&quot; &quot;(def mp {:a 1 :b})&quot; &quot;(def mp {:a 1 :b 2})&quot; &quot;(assoc [mp :a 100])&quot; &quot;(assoc mp :a 100)&quot; &quot; #{1 1}&quot; &quot; #{1 2}&quot; &quot; #{{:a 1}}&quot; &quot; #{{:a 1} {:a 1}}&quot; &quot;mp&quot; &quot;(assoc mp :a 3 :b 4)&quot; &quot;(last [12 3])&quot; &quot;(last [12 3 23 1])&quot; &quot;(conj [1 2] 3)&quot; &quot;(alength [])&quot; &quot;(count [])&quot; &quot;(count [1 2 3])&quot; &quot;(println empty-repo)&quot; &quot;(empty-repo)&quot; &quot;(nil? 1)&quot; &quot;(nil? 0)&quot; &quot;(nil? [])&quot; &quot;(empty-brach)&quot; &quot;(def empty-branch\n  { :commit-id nil }\n  )&quot; &quot;(nil? (empty-branch :commit-id))&quot; &quot;(det t {:a {:b {:c {:d {:e 1}}}}})&quot; &quot;(def t {:a {:b {:c {:d {:e 1}}}}})&quot; &quot;(get-in t [:a :b :c])&quot; &quot;(get-in t [:a :b [:c :d]])&quot; &quot;(get-in t [:a :b (flattern [:c :d])])&quot; &quot;(get-in t [:a :b (flatten [:c :d])])&quot; &quot;(flatten [:c :d])&quot; &quot;(conj [:a] (flatten [:c :d])) &quot; &quot;(flatten [:s [:c :d]])&quot; &quot;(get-in t (flatten [:a [:b :c]])) &quot; &quot;(def plus1 ((fn [x y] x + y) 1\n             )\n  )&quot; &quot;(def plus1 ((fn [x &amp;y] x + y) 1\n             )\n  )&quot; &quot;(def plus1 (partial\n             (fn [x y] x + y)\n             1\n             )\n  )&quot; &quot;(plus1 12)&quot; &quot;(plus1 = inc)&quot; &quot;(plus1 == inc)&quot; &quot;(= plus1 inc)&quot; &quot;(== plus1 inc)&quot; &quot;t&quot; &quot;(get-in t [])&quot; &quot;(let [x [1 2 nil nil nil]]\n  (match [x]\n         [([1] :seq)] :a0\n         [([1 2] :seq)] :a1\n         [([1 2 nil nil nil] :seq)] :a2\n         :else nil))&quot; &quot;(let [x [1 2 nil nil nil]]\n  (match [x]\n         [([1] :seq)] :a0\n         :else nil))&quot; &quot;(let [x [1 2 3]]\n  (match [x]\n         [[_ _ 2]] :a0\n         [[1 1 3]] :a1\n         [[1 2 3]] :a2\n         :else :a3))&quot; &quot;(let [x [1 2 3]]\n  (match [x]\n         [[_ _ 2]] 0\n         [[1 1 3]] 1\n         [[1 2 3]] 2\n         :else 3))&quot; &quot;(defn foo [v]\n  (match v\n         [x] x\n         [x y &amp; more] (+ (* x y) (foo more))\n         :else nil))&quot; &quot;(require '[clojure.core.match :refer [match]])&quot; &quot;(require '[gitlike-vcs.core :as c])&quot; &quot;(c/foo 3)&quot; &quot;(def map {:a 1 :b 2 :c 3}) &quot; &quot;(def mamap {:a 1 :b 2 :c 3}) &quot; &quot;(mamap :a)&quot; &quot;(doseq [n (range 1 101)]\n  (println\n    (match [(mod n 3) (mod n 5)]\n           [0 0] \&quot;FizzBuzz\&quot;\n           [0 _] \&quot;Fizz\&quot;\n           [_ 0] \&quot;Buzz\&quot;\n           :else n)))&quot;], :remote []}}</component>
</project>